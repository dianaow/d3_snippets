<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <script src="https://d3js.org/d3.v4.min.js"></script>
</head>
<body>
<div id="chart"></div>
<script>

  var counter = 0
  var gnodes = null
  var entered_nodes = null
  var axisPad = 6
  var radius = 10 // responsive design: modify node radius based on device's screen width

  // Dimensions of first chart (beeswarm plot)
  var screenWidth = Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
  var screenHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
  var canvasDim = { width: screenWidth, height: screenHeight * 0.5}
  var margin = {top: 30, right: 20, bottom: 20, left: 80}
  var width = canvasDim.width - margin.left - margin.right
  var height = canvasDim.height - margin.top - margin.bottom

  // CREATE DOM ELEMENTS
  var svg = d3.select("#chart").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  var x_axis = svg.append("g")
    .attr("class", "x_axis")
    .attr("transform", "translate(0," + 0 +  ")")

  var xScale = d3.scaleLinear()
    .domain([0, 1])
    .rangeRound([0, width])

  xAxis = d3.axisTop(xScale).tickSize(-height).tickPadding(20)

  d3.select(".x_axis")
    .call(xAxis)
    .call(g => {
      g.selectAll("text").attr("transform", `translate(0, -10)`)
        .attr("y", axisPad)
        .attr('fill', '#A9A9A9')
        .style('font-size', 14)
      g.selectAll("line")
        .attr('stroke', '#A9A9A9')
        .attr('stroke-dasharray', "4")
      g.select(".domain").remove()
    })

  svg.append("line")
    .attr('class', 'x_axis2_line')
    .attr('x1', xScale(0))
    .attr('x2', xScale(1))
    .attr('y1', height/2)
    .attr('y2', height/2)
    .attr('stroke', 'black')
    .attr('stroke-width', 2)

  var nodes = svg.append('g')
    .attr('class', 'nodes')

  var colorScale = d3.scaleOrdinal()
    .domain(['good', 'bad'])
    .range(['#081EFF', 'black'])

  // DATA PROCESSING
  var data = d3.range(150).map(function(d,i) {
    return {
      id: i,
      label: 'good', 
      x: xScale(getRndBias(0, 1, 0.15, 1)),
      score: getRndBias(0, 1, 0.15, 1),
      y: height/2
    }
  })
  d3.range(1,4).map(function(d,i) {
    data.push({
      id: i,
      label: 'bad', 
      score: 1,
      x: xScale(1),
      y: height/2
    })
  })
  
  // Initialize force simulation
  var simulation = d3.forceSimulation()  
    .force("x", d3.forceX(function(d) { return d.x }).strength(1))
    .force("y", d3.forceY(height / 2))
    .force("collide", d3.forceCollide(function(d,i) { return radius+2 }))

  simulation
      .nodes(data)
      .on("tick", update) 


  function update() {

    var voronoi_data = d3.voronoi()
        .extent([[-margin.left, -margin.top], [width + margin.right, height + margin.top]])
        .x(function(d) { return d.x; })
        .y(function(d) { return d.y; })
      .polygons(data)

    gnodes = nodes.selectAll('.node-group').data(voronoi_data)

    entered_nodes = gnodes.enter().append('circle')
      .attr("class", "node-group")
      .attr('r', function (d) { return radius })
      .attr('fill', function(d,i) { 
        console.log(d.data.label)
        return colorScale(d.data.label) })
      .attr('fill-opacity', 1)
      .attr('stroke', 'none')

    gnodes = gnodes.merge(entered_nodes) 

    gnodes
      .attr("transform", function(d,i) { return "translate(" + d.data.x + "," + d.data.y + ")" })

    gnodes.append("path")
      .attr("d", function(d) { return "M" + d.join("L") + "Z"; });
  }

  function ticked() {

    gnodes
      .transition()
      .duration(280)
      //.delay(function(d, i) { return i * 50 })
      .attr('r', function (d) { return radius })
      .attr("transform", function(d,i) { return "translate(" + d.x + "," + d.y + ")" })

  }

  function getRndBias(min, max, bias, influence) {
    var rnd = Math.random() * (max - min) + min,   // random in range
        mix = Math.random() * influence;           // random mixer
    return rnd * (1 - mix) + bias * mix;           // mix full range and bias
  }

</script>
</body>
</html>